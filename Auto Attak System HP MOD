//Step 1: Define the Skill in the Skill Database
//First, modify the skill definition in db/re/skill_db.yml (or db/pre-re/skill_db.yml depending on your setup).

- Id: 1001
  Name: "Auto Attack Summon"
  Description: "Summon monsters to defend the caster"
  MaxLevel: 3
  Type: "2"  # Active skill
  TargetType: "2"  # Ground target
  DamageType: "none"
  Hit: "0"
  Inf: "5"
  Element: "neutral"
  Nk: "0"
  SplashArea: "0"
  MaxCount: "0"
  SkillRange: "9"
  AfterCastActDelay: "1000"  # Delay after cast in milliseconds
  AfterCastWalkDelay: "0"
  Cooldown: "10000"  # Cooldown in milliseconds
  FixedCastTime: "2000"  # Cast time in milliseconds
  VariableCastTime: "0"
  Duration1: "300000"  # Duration in milliseconds (5 minutes)
  Duration2: "0"
  HP: "0"
  SP: "0"
  Zeny: "0"
  RequiredStatus: "0"
  RequiredStatusLevel: "0"
  WeaponType: "0"
  SplashType: "0"
  Inf2: "0"
  MaxFlags: "0"
  NoDamage: "true"
  KnockBack: "0"
  BlowCount: "0"
  DamageCount: "0"
  Inf3: "0"
  Job: "0"
  ItemRequired: []
  ItemConsumed: []
  SpiritSphereCost: "0"
  WeaponTypeRequired: []
  AmmoTypeRequired: []
  CastCancel: "true"
  CastTarget: "true"
  OverCharge: "false"
  FailNotice: "true"
  Monuments: []










//Step 2: Implement the Skill Script
//Edit skill_castend_nodamage_id in src/map/skill.cpp to add the functionality for summoning the appropriate monsters.

// Function prototype
void summon_monster(struct map_session_data* sd, int class_, int duration);

// Inside the skill_castend_nodamage_id function
case PR_AUTOATTACKSUMMON: {
    int level = skill_lv;
    int monster_class;
    int summon_count = 3; // Maximum number of summoned monsters

    // Define the monster class based on the skill level
    switch (level) {
        case 1:
            monster_class = MOBID_HIGH_PRIEST;
            break;
        case 2:
            monster_class = MOBID_SNIPER;
            break;
        case 3:
            monster_class = MOBID_LORD_KNIGHT;
            break;
        default:
            return 0;
    }

    // Summon the monsters
    for (int i = 0; i < summon_count; ++i) {
        summon_monster(sd, monster_class, skill_db[skill_id].duration1);
    }

    break;
}









//Step 3: Implement the Summon Monster Function
//Add a helper function in src/map/skill.cpp to handle monster summoning logic.

#include "../common/memmgr.h" // Ensure this include for memory management functions

// Summon a monster to follow the caster
void summon_monster(struct map_session_data* sd, int class_, int duration) {
    struct mob_data* md;
    int x = sd->bl.x;
    int y = sd->bl.y;
    int m = sd->bl.m;

    // Summon the monster
    md = mob_once_spawn(sd, m, x, y, "", class_, "", SZ_SMALL, AI_SUMMON);
    if (!md) return;

    // Set the monster to follow the caster
    md->master_id = sd->bl.id;
    md->status.skilltimer = add_timer(gettick() + duration, mob_delete_timer, md->bl.id, 0);
    md->mode = MD_CANATTACK | MD_CANMOVE | MD_CANCAST | MD_CANATTACKSKILL | MD_CANMOVESKILL; // Enable skill usage

    // Additional behavior setup can go here
}











//Step 4: Update Monster Behavior
//Ensure the summoned monsters follow the caster and teleport if they go off-screen. Modify the unit update functions in src/map/monster.cpp.


// Function prototype
void monster_follow(struct mob_data* md);

// Inside the appropriate unit update function (e.g., unit_timer)
if (md->master_id) {
    struct map_session_data* master_sd = map_id2sd(md->master_id);
    if (master_sd) {
        monster_follow(md);
    }
}

// Implement the follow logic
void monster_follow(struct mob_data* md) {
    struct map_session_data* sd = map_id2sd(md->master_id);
    if (!sd) return;

    int dist = distance(md->bl.x, md->bl.y, sd->bl.x, sd->bl.y);
    if (dist > SCREEN_DISTANCE_LIMIT) {
        // Teleport the monster to the caster
        md->bl.x = sd->bl.x + rand() % 3 - 1;
        md->bl.y = sd->bl.y + rand() % 3 - 1;
        clif_bl_update(&md->bl, &md->bl, UF_CSHIFT | UF_HEALTH | UF_SPEED);
    } else {
        // Normal follow behavior
        md->target_id = sd->bl.id;
        md->state.attack_type = 0;
        md->min_chase = 1;
        md->state.skillstate = MSS_FREE;
    }
}




//Step 4.5: Enable Skill Usage in AI
//Ensure that the AI can handle skill usage. Modify the AI logic in src/map/monster.cpp or src/map/mob.cpp to enable skill usage for summoned monsters.

void mob_ai_sub_hard(struct mob_data *md, int64 tick) {
    // Ensure the monster can use skills
    if (md->state.skillstate == MSS_FREE && md->mode & MD_CANCAST) {
        if (mob_skill_use(md, tick)) {
            md->state.skillstate = MSS_SKILLCAST;
        }
    }
}












//Step 5: Add Skill to High Priest Class
//Ensure that the High Priest class has access to the new skill by modifying the job_skill database.

// Edit db/job_exp.txt to add the skill for High Priest (job ID 0x18)
{ "PR_AUTOATTACKSUMMON", 1001, JT_HIGH_PRIEST }












//Step 6: Recompile and Test
After making these changes, recompile the server to apply the modifications:

make clean
make server

